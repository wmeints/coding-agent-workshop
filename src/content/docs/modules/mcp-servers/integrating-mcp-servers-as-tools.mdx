---
title: Integrating MCP servers in the agent loop
description: Learn how to integrate MCP server tools into your agent's core loop so the LLM can discover and use them.
---

import { Steps, Card } from '@astrojs/starlight/components';

In this lab, you'll integrate the MCP servers you connected in the previous lab
into your agent's core loop. You'll implement tool discovery, registration with
Semantic Kernel, and execution of MCP tools by the LLM.

## Lab files

- [Starter code](../../../../labs/mcp-servers/integrating-mcp-servers/start)
- [Solution code](../../../../labs/mcp-servers/integrating-mcp-servers/solution)

## Understanding tool integration

To make MCP server tools available to your agent's LLM, you need to:

1. **Discover tools** from connected MCP servers
2. **Convert** MCP tool definitions to Semantic Kernel's format
3. **Register** these tools with the Semantic Kernel
4. **Execute** MCP tools when the LLM requests them
5. **Return results** back to the LLM in a format it understands

The MCP protocol provides a standard way to discover tools through the `tools/list`
operation. Each tool has a schema describing its name, description, and parameters.
Your job is to bridge between MCP's schema format and Semantic Kernel's expectations.

## Discovering tools from MCP servers

First, you'll implement tool discovery to retrieve all available tools from
connected MCP servers.

<Steps>

1. Create a new class `McpToolDiscovery` to handle tool discovery.

   This class should:
   - Accept the `McpClientManager` to access connected servers
   - Provide a method to discover all tools across all servers
   - Return tool metadata in a format you can work with

2. Implement a method to list tools from a single MCP server.

   For each connected server:
   - Call the `tools/list` operation via the MCP client
   - Parse the response to extract tool definitions
   - Collect metadata including name, description, and parameter schema

3. Combine tools from all servers into a unified collection.

   - Prefix tool names with the server name to avoid conflicts (e.g.,
     `github_create_issue`)
   - Handle cases where servers might provide tools with the same name
   - Track which tool belongs to which server for execution later

4. Add error handling for servers that fail to respond.

   If a server fails during tool discovery:
   - Log the error with the server name
   - Continue discovering tools from other servers
   - Don't break the agent if one server is misbehaving

</Steps>

## Creating a Semantic Kernel plugin from MCP tools

Next, you'll create a dynamic Semantic Kernel plugin that represents all MCP tools
as kernel functions.

<Steps>

1. Create a class `McpToolsPlugin` to represent MCP tools in Semantic Kernel.

   This plugin should:
   - Dynamically generate kernel functions for each MCP tool
   - Store a reference to the `McpClientManager` for executing tools
   - Maintain mappings between kernel function names and MCP server/tool pairs

2. For each MCP tool, create a corresponding kernel function.

   The kernel function should:
   - Use the `[KernelFunction]` attribute with the prefixed tool name
   - Include a `[Description]` attribute from the MCP tool's description
   - Accept parameters that match the MCP tool's schema
   - Delegate execution to the appropriate MCP server

3. Convert MCP parameter schemas to Semantic Kernel parameter attributes.

   MCP tools define parameters using JSON Schema. For each parameter:
   - Extract the parameter name, type, and description
   - Create corresponding C# method parameters
   - Add `[Description]` attributes for each parameter
   - Handle optional vs. required parameters appropriately

4. Implement a generic execution handler for all MCP tools.

   When a kernel function is called:
   - Identify which MCP server and tool to invoke
   - Convert the parameters to the MCP tool's expected format
   - Call the MCP server's `tools/call` operation
   - Parse the response and return it to Semantic Kernel

</Steps>

<Card title="Dynamic function generation">
You can use Semantic Kernel's `KernelFunctionFromMethod` to create functions
dynamically at runtime. This is particularly useful when you don't know the exact
tools available until the agent starts.
</Card>

## Registering MCP tools with the kernel

Now integrate your MCP tools plugin with the Semantic Kernel in your agent loop.

<Steps>

1. Update your agent initialization to discover and register MCP tools.

   After connecting to MCP servers:
   - Use `McpToolDiscovery` to list all available tools
   - Create an instance of `McpToolsPlugin` with the discovered tools
   - Register the plugin with your Semantic Kernel instance

2. Add logging to show which MCP tools were registered.

   Log information about:
   - How many tools were discovered from each server
   - The names of registered tools
   - Any tools that failed to register

3. Handle the case where no MCP servers are configured.

   If `mcp.json` doesn't exist or contains no servers:
   - Skip MCP tool registration
   - Log an informational message (not an error)
   - Continue agent initialization normally

</Steps>

## Executing MCP tools from the agent loop

With tools registered, you need to ensure they execute correctly when the LLM
calls them.

<Steps>

1. Verify that MCP tool calls work within your agent loop.

   The existing agent loop should:
   - Already handle tool calls from Semantic Kernel
   - Automatically work with your MCP tools plugin
   - Not require changes if implemented correctly

2. Add specific error handling for MCP tool execution failures.

   When an MCP tool fails:
   - Catch the exception and log details
   - Return a clear error message to the LLM
   - Allow the agent to continue (don't crash the entire loop)

3. Implement timeout handling for slow MCP tools.

   Some MCP tools might take a long time to execute:
   - Set reasonable timeouts for tool execution (e.g., 30 seconds)
   - Cancel the operation if it exceeds the timeout
   - Report the timeout to the LLM as a tool error

4. Format MCP tool results for the LLM.

   MCP tools can return different content types:
   - Text results should be passed directly
   - Structured data might need formatting
   - Error responses should be converted to readable messages

</Steps>

## Testing MCP integration

Test your integration with real MCP servers to ensure everything works correctly.

<Steps>

1. Configure a test MCP server in `mcp.json`.

   Use a simple server like the filesystem server:
   ```json
   {
     "mcpServers": {
       "filesystem": {
         "command": "npx",
         "args": ["-y", "@modelcontextprotocol/server-filesystem", "/tmp"]
       }
     }
   }
   ```

2. Start your agent and verify tools are discovered and registered.

   Check the logs for:
   - Successful connection to the MCP server
   - Discovered tool names (e.g., `filesystem_read_file`, `filesystem_write_file`)
   - Confirmation that tools were registered with the kernel

3. Test a prompt that should trigger an MCP tool.

   Try a prompt like: "Read the file /tmp/test.txt and tell me what it contains"

   Verify that:
   - The LLM decides to use the `filesystem_read_file` tool
   - The tool is executed successfully
   - The result is returned to the LLM
   - The LLM provides a response based on the tool output

4. Test error handling by configuring an invalid server.

   Add an invalid entry to `mcp.json` and verify:
   - The agent logs the error clearly
   - The agent continues to work with valid servers
   - Invalid tools are not registered with the kernel

5. Test with multiple MCP servers.

   Configure 2-3 different servers and verify:
   - All tools are discovered
   - Tool names are properly prefixed
   - The LLM can use tools from different servers
   - No naming conflicts occur

</Steps>

## Enhancing the user experience

Add some final touches to make MCP integration transparent and helpful for users.

<Steps>

1. Add a command or flag to list available MCP tools.

   Users should be able to:
   - See what MCP servers are loaded
   - View which tools are available from each server
   - Understand tool descriptions without reading logs

2. Provide clear error messages for common configuration issues.

   Handle cases like:
   - MCP server executable not found
   - Invalid JSON in `mcp.json`
   - Missing environment variables
   - Connection failures

3. Consider adding health checks for MCP servers.

   Optionally:
   - Ping servers periodically to ensure they're still responsive
   - Reconnect automatically if a server crashes
   - Notify the user if a server becomes unavailable

</Steps>

<Card title="Production considerations">
In a production agent, consider implementing retry logic for transient failures,
circuit breakers for repeatedly failing servers, and metrics to track MCP tool
usage and performance.
</Card>

## Summary

In this lab, you've completed the MCP server integration:

- Implemented tool discovery from MCP servers
- Created a dynamic Semantic Kernel plugin for MCP tools
- Registered MCP tools with your agent's kernel
- Tested end-to-end integration with real MCP servers
- Added error handling and user-friendly features

Your coding agent can now leverage the entire ecosystem of MCP servers, dramatically
expanding its capabilities without requiring you to implement every integration
yourself.

Try exploring the [MCP servers directory](https://github.com/modelcontextprotocol/servers)
to discover what servers are available for your agent!

[Solution code](../../../../labs/mcp-servers/integrating-mcp-servers/solution) is
available if you need help or want to compare your implementation.
