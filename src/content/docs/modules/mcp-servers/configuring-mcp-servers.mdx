---
title: Configuring MCP servers
description: Learn how to configure your coding agent to load and connect to MCP servers.
---

import { Steps, Card } from '@astrojs/starlight/components';

In this lab, you'll extend your coding agent to support Model Context Protocol (MCP)
servers. You'll implement a configuration system that allows users to specify which
MCP servers to load, and build the infrastructure to connect to those servers.

By completing this lab, you'll have a flexible configuration system that reads MCP
server definitions from a JSON file, resolves environment variables for secure
credential storage, and creates client connections to both local and remote MCP servers.

## Lab files

- **Starter code**: [labs/context-engineering/002-task-memory/][LAB_START_SOURCE]
- **Solution code**: [labs/mcp-servers/001-mcp-server-configuration/][LAB_SOLUTION_SOURCE]

## Understanding MCP server configuration

Before implementing the configuration system, it's important to understand what
information MCP servers need to connect.

MCP servers can run in two modes:

**Stdio transport:** The server runs as a local process and communicates via
standard input/output. This is the most common mode for local development tools.
You need to specify the command and arguments to start the server process.

**HTTP transport:** The server runs as a remote service accessible via HTTP. You
only need to specify the URL endpoint.

Your configuration system needs to support both modes and handle sensitive
information like API keys securely. We'll allow users to set placeholder
environment variables like `${API_KEY}` in the configuration file, which your
code will resolve at runtime.

## Add the ModelContextProtocol package

First, you'll add the MCP client library to your project.

<Steps>

1. Open the `CodingAgent.csproj` file in your editor.

2. Add the `ModelContextProtocol` package reference to the CodingAgent project.
   Use version `0.4.1-preview.1` of the package.

</Steps>

## Create the McpServerConfigurationItem class

Now you'll create a class to represent a single MCP server's configuration.

<Steps>

1. Create a new directory named `Configuration` in the `CodingAgent` project.

2. Create a new file `McpServerConfigurationItem.cs` in the `Configuration` directory.

3. Define a class with properties to store MCP server connection details.

   The class should have properties for:
   - `Url` - Optional string for HTTP-based servers
   - `Command` - Optional string for the executable command (stdio servers)
   - `Arguments` - Optional list of command-line arguments
   - `EnvironmentVariables` - Optional dictionary of environment variables

   Use JSON property name attributes to map these to the expected JSON format
   (e.g., `url`, `command`, `args`, `env`).

   ```csharp title="McpServerConfigurationItem.cs"
   public class McpServerConfigurationItem
   {
      [JsonPropertyName("url")] 
      public string? Url { get; set; }

      [JsonPropertyName("command")] 
      public string? Command { get; set; }

      [JsonPropertyName("args")] 
      public List<string>? Arguments { get; set; }

      [JsonPropertyName("env")] 
      public Dictionary<string, string?>? EnvironmentVariables { get; set; }
   }
   ```

4. Implement a method `CreateClientAsync()` that returns a `Task<McpClient>`.

   This method should:
   - Validate that either a valid URL or command is provided
   - Create and return an HTTP-based `McpClient` if a URL is present
   - Create and return a stdio-based `McpClient` if a command is present
   - Throw an `InvalidOperationException` if the configuration is invalid

   Refer to the [ModelContextProtocol documentation](https://github.com/anthonychu/dotnet-mcp-sdk)
   for examples of creating `HttpClientTransport` and `StdioClientTransport` instances.

   ```diff lang="csharp" title="McpServerConfigurationItem.cs"
   public class McpServerConfigurationItem
   {
      [JsonPropertyName("url")] 
      public string? Url { get; set; }

      [JsonPropertyName("command")] 
      public string? Command { get; set; }

      [JsonPropertyName("args")] 
      public List<string>? Arguments { get; set; }

      [JsonPropertyName("env")] 
      public Dictionary<string, string?>? EnvironmentVariables { get; set; }

   +   public async Task<McpClient> CreateClientAsync()
   +   {
   +       if (!HasValidHttpConfiguration() && !HasValidStdioConfiguration())
   +       {
   +             throw new InvalidOperationException(
   +                "The specified configuration is invalid. Either a valid URL or command and arguments must be provided.");
   +       }
   + 
   +       if (HasValidHttpConfiguration())
   +       {
   +             var transportOptions = new HttpClientTransportOptions
   +             {
   +                Endpoint = new Uri(Url!),
   +             };
   +         
   +             return await McpClient.CreateAsync(new HttpClientTransport(transportOptions));
   +       }
   +       else
   +       {
   +             var transportOptions = new StdioClientTransportOptions
   +             {
   +                Command = Command!,
   +                Arguments = Arguments,
   +                EnvironmentVariables = EnvironmentVariables
   +             };
   +
   +             return await McpClient.CreateAsync(new StdioClientTransport(transportOptions));
   +       }
   +    }
   +
   +    private bool HasValidStdioConfiguration()
   +    {
   +       return !String.IsNullOrEmpty(Command);
   +    }
   +
   +    private bool HasValidHttpConfiguration()
   +    {
   +        return !string.IsNullOrEmpty(Url) && Uri.IsWellFormedUriString(Url, UriKind.Absolute);
   +    }
   }
   ```

</Steps>



## Create the McpServerConfiguration class

Next, you'll build the main configuration class that loads and manages multiple
MCP servers.

<Steps>

1. Create a new file `McpServerConfiguration.cs` in the `Configuration` directory.

2. Define a class with a private constructor that accepts a dictionary of server
   configurations.

   The class should:
   - Store the servers dictionary in a public property named `Servers`
   - Use a dictionary with string keys (server names) and `McpServerConfigurationItem` values
   - Make the constructor private to enforce using the static `Load()` method

   ```csharp title="McpServerConfiguration.cs"
   public class McpServerConfiguration
   {
      private McpServerConfiguration(Dictionary<string, McpServerConfigurationItem> servers)
      {
         Servers = servers;
      }

      public Dictionary<string, McpServerConfigurationItem> Servers { get; }
   }
   ```

3. Implement a static async method `Load(string baseDirectory)` that returns
   `Task<McpServerConfiguration>`.

   This method should:
   - Construct the path to `.agent/mcp.json` within the base directory
   - Open and read the JSON file asynchronously
   - Deserialize it to a dictionary of `McpServerConfigurationItem` objects
   - Process environment variable placeholders (see next step)
   - Return a new instance of `McpServerConfiguration`

   Refer to [System.Text.Json documentation](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/how-to)
   for async deserialization examples.

   ```diff lang="csharp" title="McpServerConfiguration.cs"
   public class McpServerConfiguration
   {
      private McpServerConfiguration(Dictionary<string, McpServerConfigurationItem> servers)
      {
         Servers = servers;
      }

      public Dictionary<string, McpServerConfigurationItem> Servers { get; }

   +   public static async Task<McpServerConfiguration> Load(string baseDirectory)
   +   {
   +      var configurationFilePath = Path.Join(baseDirectory, ".agent", "mcp.json");
   +      await using var fileStream = File.OpenRead(configurationFilePath);
   +
   +      var configuration = await JsonSerializer.DeserializeAsync<Dictionary<string, McpServerConfigurationItem>>(fileStream);
   +
   +      if (configuration is null)
   +      {
   +         throw new InvalidOperationException("Failed to load MCP server configuration.");
   +      }
   +         
   +      return new McpServerConfiguration(configuration!);
   +   }
   }
   ```

4. Implement environment variable placeholder resolution.

   Add a private static method `ResolveEnvironmentVariables()` that:
   - Takes a dictionary of environment variable names and values
   - Looks for values matching the pattern `${VARIABLE_NAME}`
   - Replaces placeholders with actual environment variable values
   - Returns the resolved dictionary

   Use a regular expression to match the placeholder pattern: `^\${(.+?)}$`

   ```diff lang="csharp" title="McpServerConfiguration.cs"
   public class McpServerConfiguration
   {
      private McpServerConfiguration(Dictionary<string, McpServerConfigurationItem> servers)
      {
         Servers = servers;
      }

      public Dictionary<string, McpServerConfigurationItem> Servers { get; }

      public static async Task<McpServerConfiguration> Load(string baseDirectory)
      {
         var configurationFilePath = Path.Join(baseDirectory, ".agent", "mcp.json");
         await using var fileStream = File.OpenRead(configurationFilePath);
   
         var configuration = await JsonSerializer.DeserializeAsync<Dictionary<string, McpServerConfigurationItem>>(fileStream);
   
         if (configuration is null)
         {
            throw new InvalidOperationException("Failed to load MCP server configuration.");
         }
            
         return new McpServerConfiguration(configuration!);
      }

   +   private static Dictionary<string, string?> ResolveEnvironmentVariables(Dictionary<string, string?> environmentVariables)
   +   {
   +      var results = new Dictionary<string, string?>();
   +      var pattern = new Regex("^\\${(.+?)}$");
   +
   +      foreach (var keyValuePair in environmentVariables)
   +      {
   +         if (!string.IsNullOrEmpty(keyValuePair.Value) && pattern.Match(keyValuePair.Value) is { Success: true } match)
   +         {
   +               var environmentVariableValue = Environment.GetEnvironmentVariable(match.Groups[1].Value);
   +               results.Add(keyValuePair.Key, environmentVariableValue);
   +               continue;
   +         }
   +         
   +         results.Add(keyValuePair.Key, keyValuePair.Value);
   +      }
   +      
   +      return results;
   +   }
   }
   ```

5. Call the resolver for each server's environment variables after loading.

   In the `Load()` method, after deserializing the configuration:
   - Iterate through each server configuration
   - If it has environment variables defined, resolve the placeholders
   - Update the server's `EnvironmentVariables` property with the resolved values

      ```diff lang="csharp" title="McpServerConfiguration.cs"
      public class McpServerConfiguration
      {
         private McpServerConfiguration(Dictionary<string, McpServerConfigurationItem> servers)
         {
            Servers = servers;
         }

         public Dictionary<string, McpServerConfigurationItem> Servers { get; }

         public static async Task<McpServerConfiguration> Load(string baseDirectory)
         {
            var configurationFilePath = Path.Join(baseDirectory, ".agent", "mcp.json");
            await using var fileStream = File.OpenRead(configurationFilePath);
      
            var configuration = await JsonSerializer.DeserializeAsync<Dictionary<string, McpServerConfigurationItem>>(fileStream);
      
            if (configuration is null)
            {
               throw new InvalidOperationException("Failed to load MCP server configuration.");
            }

      +      foreach (var (key, config) in configuration)
      +      {
      +         // Resolve any placeholders ${ENV_VAR} in environment variables.
      +         // This allows sensitive information to be stored outside the configuration file.
      +         if (config.EnvironmentVariables is { } environmentVariables)
      +         {
      +               config.EnvironmentVariables = ResolveEnvironmentVariables(environmentVariables);
      +         }
      +      }
               
            return new McpServerConfiguration(configuration!);
         }

         private static Dictionary<string, string?> ResolveEnvironmentVariables(Dictionary<string, string?> environmentVariables)
         {
            var results = new Dictionary<string, string?>();
            var pattern = new Regex("^\\${(.+?)}$");
      
            foreach (var keyValuePair in environmentVariables)
            {
               if (!string.IsNullOrEmpty(keyValuePair.Value) && pattern.Match(keyValuePair.Value) is { Success: true } match)
               {
                     var environmentVariableValue = Environment.GetEnvironmentVariable(match.Groups[1].Value);
                     results.Add(keyValuePair.Key, environmentVariableValue);
                     continue;
               }
               
               results.Add(keyValuePair.Key, keyValuePair.Value);
            }
            
            return results;
         }
      }
      ```

6. Implement a method `CreateAllClientsAsync()` that returns `Task<List<McpClient>>`.

   This method should:
   - Iterate through all configured servers
   - Call `CreateClientAsync()` on each server configuration
   - Collect all clients into a list
   - Return the list of connected clients

   ```diff lang="csharp" title="McpServerConfiguration.cs"
   public class McpServerConfiguration
   {
      private McpServerConfiguration(Dictionary<string, McpServerConfigurationItem> servers)
      {
         Servers = servers;
      }

      public Dictionary<string, McpServerConfigurationItem> Servers { get; }

      public static async Task<McpServerConfiguration> Load(string baseDirectory)
      {
         var configurationFilePath = Path.Join(baseDirectory, ".agent", "mcp.json");
         await using var fileStream = File.OpenRead(configurationFilePath);
   
         var configuration = await JsonSerializer.DeserializeAsync<Dictionary<string, McpServerConfigurationItem>>(fileStream);
   
         if (configuration is null)
         {
            throw new InvalidOperationException("Failed to load MCP server configuration.");
         }

         foreach (var (key, config) in configuration)
         {
            // Resolve any placeholders ${ENV_VAR} in environment variables.
            // This allows sensitive information to be stored outside the configuration file.
            if (config.EnvironmentVariables is { } environmentVariables)
            {
                  config.EnvironmentVariables = ResolveEnvironmentVariables(environmentVariables);
            }
         }
            
         return new McpServerConfiguration(configuration!);
      }

   +   public async Task<List<McpClient>> CreateAllClientsAsync()
   +   {
   +       var clients = new List<McpClient>();
   +
   +       foreach (var serverConfiguration in Servers)
   +       {
   +           clients.Add(await serverConfiguration.Value.CreateClientAsync());
   +       }
   +
   +       return clients;
   +   }

      private static Dictionary<string, string?> ResolveEnvironmentVariables(Dictionary<string, string?> environmentVariables)
      {
         var results = new Dictionary<string, string?>();
         var pattern = new Regex("^\\${(.+?)}$");
   
         foreach (var keyValuePair in environmentVariables)
         {
            if (!string.IsNullOrEmpty(keyValuePair.Value) && pattern.Match(keyValuePair.Value) is { Success: true } match)
            {
                  var environmentVariableValue = Environment.GetEnvironmentVariable(match.Groups[1].Value);
                  results.Add(keyValuePair.Key, environmentVariableValue);
                  continue;
            }
            
            results.Add(keyValuePair.Key, keyValuePair.Value);
         }
         
         return results;
      }
   }
   ```

</Steps>

## Add tests for the MCP server configuration

At this point it's a good idea to add a few test cases to verify the MCP
configuration works as intended. You can find the steps for writing the tests
below. You can refer to the [source
code][TEST_SOURCE]
to see the full implementation.

<Steps>

1. Create a new file `McpServerConfigurationTests.cs` in the `CodingAgent.Tests`
   project.

2. Create a test class that implements `IDisposable` for cleanup.

   The class should:
   - Maintain a list of temporary directories to clean up
   - Maintain a list of environment variables to reset
   - Implement `Dispose()` to clean up both lists after each test

3. Add helper methods for test setup.

   Create methods to:
   - Create and track temporary directories
   - Set and track environment variables for cleanup
   - These make it easy to create isolated test environments

4. Write a test to verify loading a valid stdio server configuration.

   The test should:
   - Create a temporary directory with `.agent/mcp.json`
   - Write a JSON configuration for a stdio server with command and arguments
   - Call `McpServerConfiguration.Load()` with the temp directory
   - Assert the configuration was loaded correctly
   - Verify server name, command, and arguments are as expected

5. Write a test to verify environment variable placeholder resolution.

   The test should:
   - Set an environment variable with a test value
   - Create a configuration that references it with `${VARIABLE_NAME}` syntax
   - Load the configuration
   - Assert the placeholder was resolved to the actual environment variable value

6. Write a test to verify loading an HTTP server configuration.

   The test should:
   - Create a configuration with a URL instead of command
   - Load the configuration
   - Verify the URL property is set correctly

7. Write a test to verify error handling for missing configuration files.

   The test should:
   - Attempt to load from a directory without `.agent/mcp.json`
   - Assert that an appropriate exception is thrown
   - Verify the exception type matches expected behavior

</Steps>

<Card title="Test-driven development">
Writing tests as you implement features helps you catch issues early and ensures
your configuration system is robust. These tests also serve as documentation for
how the configuration format works.
</Card>

## Verify your implementation

Before moving to the next lab, verify everything works correctly.

<Steps>

1. Run all tests to ensure they pass.

   Execute `dotnet test` in the solution directory and verify all configuration
   tests pass.

2. Create a sample `.agent/mcp.json` file in a test directory.

   Create a simple configuration like:
   ```json
   {
     "example-server": {
       "command": "node",
       "args": ["server.js"]
     }
   }
   ```

3. Verify your code compiles without warnings.

   Run `dotnet build` and address any compiler warnings or errors.

</Steps>

## Summary

In this lab, you've built a flexible configuration system for MCP servers that:

- Loads server definitions from a JSON configuration file
- Supports both stdio and HTTP transport modes
- Resolves environment variable placeholders for secure credential management
- Creates MCP client connections from configuration
- Includes comprehensive test coverage

You now have the foundation for connecting to MCP servers. In the next lab,
you'll integrate these servers into your agent's core loop so the LLM can
discover and use their tools.

[Solution code][LAB_SOLUTION_SOURCE] is available if you need help or want to
compare your implementation.

[TEST_SOURCE]: https://github.com/wmeints/coding-agent-workshop/blob/main/labs/mcp-servers/001-mcp-server-configuration/CodingAgent.Tests/AgentInstructionsTests.cs
[LAB_START_SOURCE]: https://github.com/wmeints/coding-agent-workshop/tree/main/labs/context-engineering/002-task-memory
[LAB_SOLUTION_SOURCE]: https://github.com/wmeints/coding-agent-workshop/tree/main/labs/mcp-servers/001-mcp-server-configuration