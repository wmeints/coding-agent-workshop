---
title: Adding context awareness
description: This lab teaches you how to give the coding agent awareness of its surrounding by extending the instructions with template variables.
---

import { Aside, Card, Steps } from '@astrojs/starlight/components';

In this lab we're going to make the agent more aware of the context it is
running in. So far we've kept the instructions fairly basic and static, but
that's not going to help us when we want to allow the agent to explore code
bases and make changes.

We'll use a prompt template rather than static instructions to help the agent
with context about our project. For this we'll add two variables to the system
instructions:

- Operating System: The current operating system (Linux, Windows, MacOS)
- Current Directory: The current working directory of the agent

## Lab files

- **Starter:** [labs/agent-loop/004-testing-agents](/labs/agent-loop/004-testing-agents)
- **Solution:** [labs/tools/001-context-awareness](/labs/tools/001-context-awareness)

## Create the AgentContext class

The agent needs to know about its operating environment to execute commands
correctly. Let's create a context class to capture this information.

<Steps>

1. Create a new file called `AgentContext.cs` in the `CodingAgent` project.

2. Add two properties to the `AgentContext` class:

   - `WorkingDirectory` (string) - stores the current working directory
   - `OperatingSystem` (string) - stores the name of the operating system

   ```csharp title="AgentContext.cs" ins={3-4}
   public class AgentContext
   {
      public string WorkingDirectory { get; set; } = "";
      public string OperatingSystem { get; set; } = "Unknown";
   }
   ```

3. Add a static factory method called `Create` that accepts an optional
   `workingDirectory` parameter. This method should:
   - Detect the current operating system using the `System.OperatingSystem`
     class methods (`IsWindows()`, `IsLinux()`, `IsMacOS()`)
   - Set the `OperatingSystem` property to "Windows", "Linux", "MacOS", or
     "Unknown"
   - Use the provided `workingDirectory` parameter, or fall back to
     `Directory.GetCurrentDirectory()` if not provided
   - Return a new instance of `AgentContext` with these values

   ```csharp title="AgentContext.cs" ins={6-28}
   public class AgentContext
   {
      public string WorkingDirectory { get; set; } = "";
      public string OperatingSystem { get; set; } = "Unknown";

      public static AgentContext Create(string? workingDirectory = null)
      {
         string operatingSystem = "Unknown";
         
         if (System.OperatingSystem.IsWindows())
         {
               operatingSystem = "Windows";    
         }
         else if (System.OperatingSystem.IsLinux())
         {
               operatingSystem = "Linux";
         }
         else if (System.OperatingSystem.IsMacOS())
         {
               operatingSystem = "MacOS";
         }

         return new AgentContext
         {
               WorkingDirectory = workingDirectory ?? Directory.GetCurrentDirectory(),
               OperatingSystem = operatingSystem,
         };
      }
   }
   ```

4. Update the `Agent` class constructor to accept an `AgentContext` parameter
   and store it as a field.

   ```diff lang="csharp" title="Agent.cs"
   public class Agent
   {
      private ChatHistory _chatHistory;
      private readonly Kernel _kernel;
      private readonly IAgentInstructions _agentInstructions;
   +  private readonly AgentContext _context;

   -  public Agent(Kernel kernel, IAgentInstructions agentInstructions)
   +  public Agent(Kernel kernel, AgentContext context, IAgentInstructions agentInstructions)
      {
         _chatHistory = new ChatHistory();
         _kernel = kernel;
   +     _context = context;
         _agentInstructions = agentInstructions;

         _kernel.Plugins.Add(ShellPluginFactory.Create());
      }

      // The rest of the code
   }

5. Update `Program.cs` to create an `AgentContext` using the factory method and
   pass it to the `Agent` constructor.

   ```diff lang="csharp" title="Program.cs"
   var kernel = kernelBuilder.Build();
   var instructions = new AgentInstructions();
   + var context = AgentContext.Create();
   - var agent = new Agent(kernel, instructions);
   + var agent = new Agent(kernel, context, instructions);
   ```

</Steps>

## Update the agent instructions

We're going to need a way to tell the agent about the agent context. We'll
extend the agent instructions component we created earlier to use a prompt
template with template variables for the operating system and working directory.

<Steps>

1. Add a reference to the `Microsoft.SemanticKernel.PromptTemplates.Handlebars`
   NuGet package to your project.

1. Update the `IAgentInstructions` interface to accept an `AgentContext`
   parameter in the `InjectAsync` method.


   ```diff lang="csharp" title="AgentInstructions.cs"
   public interface IAgentInstructions
   {
   -   Task InjectAsync(Kernel kernel, ChatHistory chatHistory);
   +   Task InjectAsync(Kernel kernel, AgentContext context, ChatHistory chatHistory);
      void Remove(ChatHistory chatHistory);
   }
   ```

1. Modify the `AgentInstructions` class to use the Handlebars template engine.
   In the `ReadSystemInstructionsAsync` method:
   - Create a `PromptTemplateConfig` with the template loaded from the embedded resource
   - Set the `TemplateFormat` to "handlebars"
   - Create a `HandlebarsPromptTemplateFactory` instance (set
     `AllowDangerouslySetContent = true` to allow HTML-like content)
   - Use the factory to create a prompt template from the configuration
   - Render the template with `KernelArguments` containing the context values
     (`operating_system` and `working_directory`)

   ```diff lang="csharp" title="AgentInstructions.cs"  
   using Microsoft.SemanticKernel;
   using Microsoft.SemanticKernel.ChatCompletion;
   +using Microsoft.SemanticKernel.PromptTemplates.Handlebars;
   
   namespace CodingAgent;
   
   public class AgentInstructions : IAgentInstructions
   {
   -    public async Task InjectAsync(ChatHistory chatHistory)
   +    public async Task InjectAsync(Kernel kernel, AgentContext context, ChatHistory chatHistory)
      {
   -        var systemPrompt = await ReadSystemInstructionsAsync();
   +        var systemPrompt = await ReadSystemInstructionsAsync(kernel, context);
            chatHistory.Insert(0, new ChatMessageContent(AuthorRole.System, systemPrompt));
      }
   
      public void Remove(ChatHistory chatHistory)
      {
            if (chatHistory.Count > 0 && chatHistory[0].Role == AuthorRole.System)
            {
               chatHistory.RemoveAt(0);
            }
      }
   
   -    private async Task<string> ReadSystemInstructionsAsync()
   +    private async Task<string> ReadSystemInstructionsAsync(Kernel kernel, AgentContext context)
      {
   -        var resourceName = "CodingAgent.Resources.AgentSystemInstructions.txt";
   -        var instructions = EmbeddedResource.Read(resourceName);
   -        return await Task.FromResult(instructions);
   +        var promptTemplateConfig = new PromptTemplateConfig
   +        {
   +            Template = EmbeddedResource.Read("CodingAgent.Resources.AgentSystemInstructions.txt"),
   +            TemplateFormat = "handlebars"
   +        };
   +
   +        var promptTemplateFactory = new HandlebarsPromptTemplateFactory
   +        {
   +            AllowDangerouslySetContent = true
   +        };
   +        
   +        var promptTemplate = promptTemplateFactory.Create(promptTemplateConfig);
   +
   +        return await promptTemplate.RenderAsync(kernel, new KernelArguments
   +        {
   +            ["operating_system"] = context.OperatingSystem,
   +            ["working_directory"] = context.WorkingDirectory
   +        });
      }
   }

   ```

1. Modify the `Agent` class to pass the `AgentContext` and `Kernel` instance to
   the `InjectAsync` method when injecting the instructions.

   ```diff lang="csharp"  title="Agent.cs"
   public async Task InvokeAsync(string prompt, IAgentCallbacks callbacks)
   {
         var chatCompletionService = _kernel.GetRequiredService<IChatCompletionService>();

   -     await _agentInstructions.InjectAsync(_chatHistory);
   +     await _agentInstructions.InjectAsync(_kernel, _context, _chatHistory);
         _chatHistory.AddUserMessage(prompt);

         while (true)
         {
            var promptExecutionSettings = new AzureOpenAIPromptExecutionSettings()
            {
               FunctionChoiceBehavior = FunctionChoiceBehavior.Auto(autoInvoke: false),
            };

            var response = await chatCompletionService.GetChatMessageContentAsync(
               _chatHistory, promptExecutionSettings);

            _chatHistory.Add(response);

            if (!string.IsNullOrEmpty(response.Content))
            {
               await callbacks.ReportAgentResponseAsync(response.Content);
            }

            var functionCalls = FunctionCallContent.GetFunctionCalls(response).ToList();

            if (!functionCalls.Any())
            {
               // End the agent turn when there are no more function calls to process.
               break;
            }

            await HandleFunctionCalls(functionCalls, callbacks);
         }

         _agentInstructions.Remove(_chatHistory);
   }
   ```

</Steps>

## Add unit-tests for the instructions

Let's verify that the instructions are rendered correctly with the context information.

<Steps>

1. Create a new test file called `AgentInstructionsTests.cs` in the `CodingAgent.Tests` project.

   ```csharp title="AgentInstructionsTests.cs"
   public class AgentInstructionsTests
   {
      
   }
   ```

2. Add a test method called `InjectAsync_ShouldIncludeOperatingSystemAndWorkingDirectory` that:
   - Creates an instance of `AgentInstructions`
   - Creates an `AgentContext` with specific test values (e.g., WorkingDirectory = "/home/user/projects", OperatingSystem = "Linux")
   - Creates a minimal `Kernel` instance using `Kernel.CreateBuilder().Build()`
   - Creates an empty `ChatHistory`
   - Calls `InjectAsync` to inject the instructions
   - Asserts that the chat history contains exactly one message
   - Asserts that the message role is `AuthorRole.System`
   - Asserts that the message content includes both the working directory and operating system values

   ```csharp title="AgentInstructionsTests.cs" ins={4-22}
   [Fact]
   public async Task InjectAsync_ShouldIncludeOperatingSystemAndWorkingDirectory()
   {
      // Arrange
      var agentInstructions = new AgentInstructions();
      var context = new AgentContext
      {
            WorkingDirectory = "/home/user/projects",
            OperatingSystem = "Linux"
      };

      var kernel = Kernel.CreateBuilder().Build();
      var chatHistory = new ChatHistory();

      // Act
      await agentInstructions.InjectAsync(kernel, context, chatHistory);

      // Assert
      Assert.Single(chatHistory);
      Assert.Equal(AuthorRole.System, chatHistory[0].Role);
      Assert.Contains("/home/user/projects", chatHistory[0].Content);
      Assert.Contains("Linux", chatHistory[0].Content);
   }
   ```

3. Run the tests using `dotnet test` to verify the instructions are rendered correctly.

</Steps>

## Summary

In this lab, you made the coding agent context-aware by:

- Creating an `AgentContext` class to capture the operating system and working directory
- Implementing a factory method to automatically detect the operating environment
- Converting the static agent instructions to use Handlebars templates with template variables
- Embedding the instruction template as a resource in your project
- Writing unit tests to verify that context information is correctly rendered in the agent's instructions

The agent now has awareness of its environment, which will be essential when adding shell execution capabilities in future labs. You can find the complete solution in `/home/wmeints/Work/coding-agent-workshop/labs/tools/001-context-awareness/solution`.