---
title: Building the Text Editor Plugin
description: This tutorial teaches you how to build a Text Editor Plugin for the coding agent.
next:
    label: Context engineering
---

import { Steps, Aside } from '@astrojs/starlight/components';

In this lab, we'll add a text editor plugin to our coding agent. If you've used
the agent from the previous lab (which you should totally do, because it works!),
you'll notice that it edits files using a rather unlikely toolset. For example,
on Linux it will use sed/cat/echo and other tools to manipulate files. While it
works, it's not very pretty to see.

A better approach is to add a text editor plugin that provides tools to view
and edit files directly. This is what we'll do in this lab.

We'll need to create several tools:

- The `view_file` tool to view the contents of a file. This tool can show fragments, as well as full file contents.
- The `write_file` tool to write contents to a file, replacing any existing content or creating new files.
- The `insert_text` tool to insert text at a specific line in a file.
- The `replace_text` tool to replace text in a file between specific line numbers.

Let's get started building the plugin class first.

## Lab files

- **Starter:** [labs/tools/002-shell-plugin][LAB_START_SOURCE]
- **Solution:** [labs/tools/003-text-editor-plugin][LAB_SOLUTION_SOURCE]

## Create the FileLocation helper class

Before building the main plugin, we'll create a helper class to resolve file paths.
This class handles platform-specific path resolution, such as expanding environment
variables on Windows and the home directory shortcut on Unix systems.

<Steps>

1. Create a new class `FileLocation` in the `Plugins/TextEditor` directory.

2. Add a static method `Resolve` that takes a relative path and returns an absolute path.
   The method should:
   - On Windows: Replace `%USERPROFILE%` and `%APP_DATA%` with their environment variable values
   - On Unix (macOS/Linux): Replace `~` with the user's home directory
   - Convert the resulting path to an absolute path using `Path.GetFullPath()`

   Refer to the [.NET documentation on OperatingSystem](https://learn.microsoft.com/en-us/dotnet/api/system.operatingsystem)
   for guidance on detecting the operating system.

</Steps>

<Aside type="note">
I noticed that while building this plugin, the coding coding agent sometimes
refers to `~/some-file` or `%USERPROFILE%/some-file` paths when asked to create or edit files.

Both of these locations are aliases to real paths. In the shell plugin, we don't
need to worry about this, because CMD and Bash will resolve the correct locations for us.

The text editor, however, is a different tool and needs specific handling for aliased 
file locations. That's why we created the `FileLocation` helper class to resolve these paths.
</Aside>

## Create the TextEditorPlugin class

Now we'll create the main plugin class that contains all the file editing tools.

<Steps>

1. Create a new class `TextEditorPlugin` in the `Plugins/TextEditor` directory.

2. Add the necessary using statements for `System.ComponentModel`, `System.Text`,
   `System.Text.RegularExpressions`, and `Microsoft.SemanticKernel`.

</Steps>

You should end up with a class that looks like this:

```csharp title="Plugins/TextEditor/TextEditorPlugin.cs"
using System.ComponentModel;
using System.Text;
using System.Text.RegularExpressions;
using Microsoft.SemanticKernel;

namespace CodingAgent.Plugins.TextEditor;

public class TextEditorPlugin
{
    // Tool implementations will go here
}
```

## Add the view_file tool

The `view_file` tool allows the agent to read file contents, either in full or
specific line ranges. This is essential for understanding existing code before
making changes.

<Steps>

1. Add a kernel function named `view_file` to the `TextEditorPlugin` class with the
   following parameters:
   - `path` - The path of the file to view
   - `from` - The start line number (1-indexed)
   - `to` - The end line number (1-indexed), or -1 to read to the end of the file

   Use the `KernelFunction` and `Description` attributes to mark the method.
   The description should explain that this tool is used to view file contents.

2. Implement the function to:
   - Use the `FileLocation.Resolve()` method to get the absolute path
   - Read all lines from the file using `File.ReadAllLinesAsync()`
   - Handle the special case where `to` is -1 (read to end of file)
   - Clamp the `to` value to the actual file length using `Math.Clamp()`
   - Build the output by iterating from `from - 1` to `to` (remember: parameters are 1-indexed, but arrays are 0-indexed)
   - Return the lines as a string

   Refer to the [Semantic Kernel documentation on creating plugins from classes](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-the-kernelfunction-decorator)
   for guidance on creating kernel functions.

</Steps>

The final implementation of the `view_file` tool should look like this:

```csharp title="Plugins/TextEditor/TextEditorPlugin.cs"
[KernelFunction("view_file")]
[Description("Use this tool to view the contents of a file.")]
public async Task<string> ViewFile(
    [Description("The path of the file you want to view")] string path,
    [Description("The start line number (1-indexed)")] int from,
    [Description("The end line number (1-indexed). Use -1 to read to the end of the file")] int to)
{
    var fileLocation = FileLocation.Resolve(path);
    var lines = await File.ReadAllLinesAsync(fileLocation);

    var outputBuilder = new StringBuilder();

    to = to == -1 ? lines.Length : to;
    to = Math.Clamp(to, 1, lines.Length);

    for (int index = from - 1; index < to; index++)
    {
        outputBuilder.AppendLine(lines[index]);
    }

    return outputBuilder.ToString();
}
```

## Add the write_file tool

The `write_file` tool creates new files or completely replaces existing file contents.

<Steps>

1. Add a kernel function named `write_file` with parameters:
   - `path` - Path to the file to create or replace
   - `content` - The content to write to the file

   Describe this tool as creating a new file with the specified content.

2. Implement the function to:
   - Resolve the file path using `FileLocation.Resolve()`
   - Write the content to the file using `File.WriteAllTextAsync()`

</Steps>

The final implementation of the `write_file` tool should look like this:

```csharp title="Plugins/TextEditor/TextEditorPlugin.cs"
[KernelFunction("write_file")]
[Description("Use this tool to create a new file with the content you want. The file must not already exist.")]
public async Task WriteFile(
    [Description("Path to the new file")] string path,
    [Description("The content you want in the new file")] string content)
{
    var fileLocation = FileLocation.Resolve(path);
    await File.WriteAllTextAsync(fileLocation, content);
}
```


## Add the insert_text tool

The `insert_text` tool allows the agent to insert new text at a specific line
in an existing file without replacing existing content.

<Steps>

1. Add a kernel function named `insert_text` with parameters:
   - `path` - The path to the existing file
   - `line` - Line number to insert at (0 inserts at the start of the file)
   - `content` - Content to insert

   Describe this tool as inserting text into an existing file at a specific line number.

2. Implement the function to:
   - Resolve the file path
   - Check if the file exists; if not, throw a `FileNotFoundException`
   - Read all lines from the file
   - Clamp the `line` parameter to valid values (0 to file length) using `Math.Clamp()`
   - Build the output by:
     - Iterating through existing lines
     - When reaching the insertion point, add the new content
     - Include the original line after the inserted content
   - Handle the edge case where `line` equals the file length (append at end)
   - Write the updated content back to the file

</Steps>

The final implementation of the `insert_text` tool should look like this:

```csharp title="Plugins/TextEditor/TextEditorPlugin.cs"
[KernelFunction("insert_text")]
[Description("Use this tool to insert text into an existing file at a specific line number.")]
public async Task InsertText(
    [Description("The path to the existing file")] string path,
    [Description("Line number to insert the text at. Use 0 to insert the text at the start of the file.")] int line,
    [Description("Content to insert into the existing file")] string content)
{
    var fileLocation = FileLocation.Resolve(path);

    if (!File.Exists(fileLocation))
    {
        throw new FileNotFoundException("The specified file does not exist.", fileLocation);
    }

    var lines = await File.ReadAllLinesAsync(fileLocation);

    line = Math.Clamp(line, 0, lines.Length);
    var outputBuilder = new StringBuilder();

    for (int index = 0; index < lines.Length; index++)
    {
        if (index == line)
        {
            outputBuilder.AppendLine(content);
        }

        outputBuilder.AppendLine(lines[index]);
    }

    // If the line is at the end of the file, append it now.
    if (line == lines.Length)
    {
        outputBuilder.AppendLine(content);
    }

    await File.WriteAllTextAsync(fileLocation, outputBuilder.ToString());
}
```

## Add the replace_text tool

The `replace_text` tool replaces specific text in a file. It includes validation
to ensure the text to replace is unique, preventing unintended changes.

<Steps>

1. Add a kernel function named `replace_text` with parameters:
   - `path` - Path to the existing file
   - `oldText` - The original text to replace
   - `newText` - The new text to use as replacement

   Describe this tool as replacing text in a file, emphasizing that the old text
   must be unique to avoid unintended replacements.

2. Implement the function to:
   - Resolve the file path
   - Read the entire file content using `File.ReadAllTextAsync()`
   - Create a `Regex` pattern from `oldText` with `RegexOptions.Multiline`
   - Find all matches of the pattern in the file content
   - If there's more than one match, throw an `InvalidOperationException` to prevent
     unintended replacements
   - Replace the matched text with the new text using the regex
   - Write the updated content back to the file

   Refer to the [.NET documentation on Regex](https://learn.microsoft.com/en-us/dotnet/standard/base-types/regular-expressions)
   for guidance on using regular expressions for text replacement.

</Steps>

The final implementation of the `replace_text` tool should look like this:

```csharp title="Plugins/TextEditor/TextEditorPlugin.cs"
[KernelFunction("replace_text")]
[Description(
    """
    Use this tool to replace a piece of text in an existing file with new text. Make sure the 
    old text is unique in the file to avoid unintended replacements.
    """)]
public async Task ReplaceText(
    [Description("Path to the existing file")] string path,
    [Description("The original text to replace in the file")] string oldText,
    [Description("The new text to replace the old text with")] string newText)
{
    var fileLocation = FileLocation.Resolve(path);
    var fileContent = await File.ReadAllTextAsync(fileLocation);

    var matchPattern = new Regex(oldText, RegexOptions.Multiline);
    var matches = matchPattern.Matches(fileContent);

    if (matches.Count > 1)
    {
        throw new InvalidOperationException(
            "The text to replace is not unique in the file. Aborting replacement to avoid unintended changes."
        );
    }

    var updatedContent = matchPattern.Replace(fileContent, newText);

    await File.WriteAllTextAsync(fileLocation, updatedContent);
}
```

## Register the text editor plugin

Finally, we'll integrate the text editor plugin into our agent.

<Steps>

1. Open the `Agent.cs` file in the CodingAgent project.

2. In the constructor of the `Agent` class, after registering the shell plugin,
   add the text editor plugin by calling `_kernel.Plugins.AddFromObject(new TextEditorPlugin())`.

3. Add the necessary using statement for the `CodingAgent.Plugins.TextEditor` namespace.

</Steps>

The constructor for the `Agent` class should now look like this:

```diff lang="csharp" title="Agent.cs"
  using CodingAgent.Plugins.Shell;
+ using CodingAgent.Plugins.TextEditor;
  using Microsoft.SemanticKernel;
  using Microsoft.SemanticKernel.ChatCompletion;
  using Microsoft.SemanticKernel.Connectors.AzureOpenAI;
 
  namespace CodingAgent;
 
  public class Agent
  {
     private ChatHistory _chatHistory;
     private readonly Kernel _kernel;
     private readonly IAgentInstructions _agentInstructions;
     private readonly AgentContext _context;
 
     public Agent(Kernel kernel, AgentContext context, IAgentInstructions agentInstructions)
     {
         _chatHistory = new ChatHistory();
         _kernel = kernel;
         _context = context;
         _agentInstructions = agentInstructions;
 
         _kernel.Plugins.Add(ShellPluginFactory.Create());
+        _kernel.Plugins.AddFromObject(new TextEditorPlugin());
     }

     // The rest of the class
  }
```

## Test the text editor plugin

I recommend adding unit-tests for the text editor plugin to ensure each tool
works as expected. On top of the unit-tests, we can also run some quick tests on
the terminal.

<Steps>

1. Run the agent application.

2. Ask the agent to create a new file with some content, for example:
   "Create a file called hello.txt with the content 'Hello, World!'"

3. Ask the agent to view the file: "Show me the contents of hello.txt"

4. Ask the agent to insert text: "Add 'This is a new line' at line 1 in hello.txt"

5. Ask the agent to replace text: "Replace 'World' with 'Universe' in hello.txt"

6. Verify that each operation works as expected and that the agent is using the
   text editor tools instead of shell commands like sed or echo.

</Steps>

## Summary

In this lab, we built the text editor plugin for our coding agent. We created
tools for viewing files (`view_file`), creating new files (`write_file`),
inserting text at specific locations (`insert_text`), and replacing text with
validation (`replace_text`). We also built a helper class to handle
platform-specific aliased path resolution.

With this text editor plugin, our agent can now edit files in a more controlled
and predictable way, making it more reliable for code modification tasks.

You can find the solution for the lab here: [labs/tools/003-text-editor-plugin][LAB_SOLUTION_SOURCE]

[LAB_START_SOURCE]: https://github.com/wmeints/coding-agent-workshop/tree/main/labs/tools/002-shell-plugin
[LAB_SOLUTION_SOURCE]: https://github.com/wmeints/coding-agent-workshop/tree/main/labs/tools/003-text-editor-plugin