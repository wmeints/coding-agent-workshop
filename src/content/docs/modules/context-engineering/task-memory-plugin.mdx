---
title: Build the Task Memory Plugin
description: Implement a task memory system using TODO items to improve plan adherence.
next:
   label: Extending your agent further
---

import { Steps } from '@astrojs/starlight/components';

In this lab, you'll build the `TaskMemoryPlugin` that enables the agent to
create, update, and track TODO items. This dramatically improves the agent's
ability to complete complex multi-step tasks by giving it a structured way to
break down work, track progress, and maintain focus.

Without task memory, agents often lose track of their plan partway through
execution, skip steps, or mark tasks as complete prematurely. By implementing
this plugin, you'll provide the agent with a reliable mechanism to manage its
work systematically.

## Lab files

- **Starter code**: [labs/context-engineering/001-custom-instructions/][LAB_START_SOURCE]
- **Solution code**: [labs/context-engineering/002-task-memory/][LAB_SOLUTION_SOURCE]

## Create the TodoItem class

The foundation of task memory is a data structure to represent individual TODO
items. Each item needs to track what needs to be done and its current status.

<Steps>

1. Create a new folder `Plugins/TaskMemory` in your project.

2. Create a `TodoItem.cs` class in the `Plugins/TaskMemory` folder.

3. Add two properties to the `TodoItem` class:
   - `Content` - a string that describes what needs to be done
   - `Status` - a string that tracks whether the item is "pending", "in_progress", or "completed"

4. Annotate both properties with `[JsonPropertyName]` attributes to ensure proper
   serialization when the agent interacts with the plugin. Refer to the
   [System.Text.Json documentation](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/customize-properties)
   for guidance on property name customization.

5. Add a `[Description]` attribute to the `Status` property that explains the
   valid status values. This helps the language model understand how to use the
   property correctly. They should be `pending`, `in_progress`, and `completed`.

</Steps>


After performing these steps you should end up with a TodoItem class similar
to the following:

```csharp
public class TodoItem
{
    [JsonPropertyName("content")]
    public string Content { get; set; }
    
    [JsonPropertyName("status")]
    [Description("The status of the TODO item (pending, in_progress, or completed)")]
    public string Status { get; set; }
}
```

## Create the TaskMemoryPlugin class

Now you'll implement the plugin that manages the TODO list. This plugin needs
two core functions: one to write TODO items and one to read them back.

<Steps>

1. Create a `TaskMemoryPlugin.cs` class in the `Plugins/TaskMemory` folder.

2. Add a private field `_todoItems` of type `List<TodoItem>` to store the TODO list.

3. Implement a `WriteTodos` method that:
   - Accepts a `List<TodoItem>` parameter named `todos`
   - Stores the provided list in the `_todoItems` field
   - Returns `void`

4. Annotate the `WriteTodos` method with:
   - `[KernelFunction("write_todos")]` - This gives the function an explicit name
   - `[Description]` - Add comprehensive instructions that tell the agent when and how to use this tool

5. In the description for `WriteTodos`, include guidance on:
   - When to use the tool (multi-step tasks, complex tasks, multiple user requests)
   - How to manage task states (mark as in_progress when starting, completed when done)
   - Task completion requirements (fully complete tasks before moving on)
   - Task breakdown guidelines (create specific, actionable items)

6. Add a `[Description]` attribute to the `todos` parameter to explain what it represents.

7. Implement a `ReadTodos` method that:
   - Returns the current `_todoItems` list
   - Has no parameters
   - Is annotated with `[KernelFunction]` and a `[Description]` explaining its purpose

</Steps>

After implementing these steps, you should have a `TaskMemoryPlugin` class similar to the following:

```csharp
public class TaskMemoryPlugin
{
    private List<TodoItem> _todoItems;
    
    [KernelFunction("write_todos")]
    [Description(
        """
        Use this tool for the following scenarios:
        
        1. Multi-step tasks
        2. Complex and non-trivial tasks
        3. When the user asks you to make a TODO list
        4. When the user provides you with multiple tasks to perform
        5. The plan needs multiple revisions from the first few steps
        
        How to use this tool:
        
        - Mark tasks as 'in_progress' when you start working on them.
        - Mark tasks as 'completed' immediately after you finish them.
        - Remove completed tasks from the list to keep it clean.
        - Only work on one task at a time to maintain focus.
        - IMPORTANT: When you create a TODO list, the first task is set to `in_progress` immediately.
        - IMPORTANT: Mark TODO items IMMEDIATELY as completed after finishing a task.
        
        Task completion requirements:
        
        - Each task must be fully completed before moving on to the next.
        - Do not mark a task as `completed` if there are any remaining issues.
        
        Task break down guidelines:
        
        - Create specific actionable items.
        - Break complex tasks into smaller tasks that can be completed in one step.
        - Use clear, descriptive task names.
        """
    )]
    public void WriteTodos([Description("The TODO items")] List<TodoItem> todos)
    {
        _todoItems = todos;
    }

    [KernelFunction]
    [Description("Use this tool to read the current TODO list.")]
    public List<TodoItem> ReadTodos()
    {
        return _todoItems;
    }
}
```

It's okay if your description is shorter than the one shown above. The key is to
provide clear instructions. You may need to tweak the wording based on how well
the agent follows the instructions during testing.

Refer to the [Semantic Kernel plugins
documentation](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/)
for more details on creating plugin methods and using attributes.

## Integrate the plugin with the agent

With the plugin implemented, you need to register it with the Semantic Kernel
so the agent can use it.

<Steps>

1. Open the `Agent.cs` file.

2. Add a using statement for `CodingAgent.Plugins.TaskMemory` at the top of the file.

3. In the `Agent` constructor, after the existing plugin registrations, add a new
   line to register the `TaskMemoryPlugin`:
   ```csharp
   _kernel.Plugins.AddFromObject(new TaskMemoryPlugin());
   ```

</Steps>

## Enhance the console callbacks

To provide better visibility into the agent's planning process, you can update the
`ConsoleCallbacks` class to handle the calls to the `write_todo` separately
introducing custom formatting.

<Steps>
1. Open the `ConsoleCallbacks.cs` file
2. In the `ReportFunctionCallAsync` method, add a new case to handle the
   `write_todos` function:
   ```csharp
   if(functionName == "write_todos")
   {
      ReportTodoItemListCall(JsonSerializer.Deserialize<List<TodoItem>>(arguments!["todos"].ToString()));
      return Task.CompletedTask;
   }
   ```

3. Implement the `ReportTodoItemListCall` method to format and display the
   TODO items using `Spectre.Console` markup.

</Steps>

Refer to the [Spectre.Console documentation](https://spectreconsole.net/markup)
for details on text formatting and markup syntax.

## Test the implementation

Run your agent and test the task memory plugin with a multi-step request.

<Steps>

1. Build and run the application:
   ```bash
   dotnet run
   ```

2. Try a complex request that requires multiple steps, such as:
   ```
   Create a new C# class called Calculator with add and subtract methods, then write unit tests for it
   ```

3. Observe how the agent:
   - Creates a TODO list at the start
   - Marks tasks as in-progress when working on them
   - Marks tasks as completed when finished
   - Follows the plan systematically

4. Experiment with different types of requests to see how the agent uses task
   memory to organize its work.

</Steps>

## Summary

You've successfully implemented a task memory system that transforms how your
agent handles complex tasks. By providing structured TODO management, you've
enabled the agent to:

- Break down complex requests into actionable steps
- Track progress systematically
- Maintain focus on the current task
- Complete work more reliably

The combination of custom instructions and task memory creates a powerful
foundation for building capable coding agents.

Find the solution for the lab here: [labs/context-engineering/002-task-memory/][LAB_SOLUTION_SOURCE]

[LAB_START_SOURCE]: https://github.com/wmeints/coding-agent-workshop/tree/main/labs/context-engineering/001-custom-instructions
[LAB_SOLUTION_SOURCE]: https://github.com/wmeints/coding-agent-workshop/tree/main/labs/context-engineering/002-task-memory
