---
import MarpCore from '@marp-team/marp-core';
const Marp = MarpCore.default || MarpCore;

interface Props {
  moduleName: string;
}

const { moduleName } = Astro.props;

// Load all slides using Vite glob
const allSlides = import.meta.glob('../slides/*.md', {
  query: '?raw',
  import: 'default',
  eager: true
});

// Find the matching slide file
const slidePath = `../slides/${moduleName}.md`;
const slideContent = allSlides[slidePath] as string | undefined;

let slidesHtml: string[] = [];
let slidesCss = '';

if (slideContent) {
  const marp = new Marp({
    html: true,
    emoji: {
      shortcode: true,
      unicode: true,
    },
  });

  const { html, css } = marp.render(slideContent);

  // Extract individual slides from the rendered HTML
  // Marp wraps each slide in a <section> tag
  const slideMatches = html.match(/<section[^>]*>[\s\S]*?<\/section>/g);
  slidesHtml = slideMatches || [];
  slidesCss = css;
}

const hasSlides = slidesHtml.length > 0;
---

{hasSlides && (
  <div class="marp-slides-container">
    <style set:html={slidesCss}></style>
    <div class="marp-slides-wrapper">
      <div class="marp-slides" data-slide-count={slidesHtml.length}>
        {slidesHtml.map((slide, index) => (
          <div
            class={`marp-slide ${index === 0 ? 'active' : ''}`}
            data-slide-index={index}
            set:html={slide}
          />
        ))}
      </div>
      <div class="marp-controls">
        <button class="marp-prev" aria-label="Previous slide" disabled>
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="15 18 9 12 15 6"></polyline>
          </svg>
        </button>
        <span class="marp-counter">
          <span class="marp-current">1</span> / <span class="marp-total">{slidesHtml.length}</span>
        </span>
        <button class="marp-next" aria-label="Next slide">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="9 18 15 12 9 6"></polyline>
          </svg>
        </button>
        <button class="marp-fullscreen" aria-label="Toggle fullscreen">
          <svg class="icon-expand" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="15 3 21 3 21 9"></polyline>
            <polyline points="9 21 3 21 3 15"></polyline>
            <line x1="21" y1="3" x2="14" y2="10"></line>
            <line x1="3" y1="21" x2="10" y2="14"></line>
          </svg>
          <svg class="icon-compress" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="4 14 10 14 10 20"></polyline>
            <polyline points="20 10 14 10 14 4"></polyline>
            <line x1="14" y1="10" x2="21" y2="3"></line>
            <line x1="3" y1="21" x2="10" y2="14"></line>
          </svg>
        </button>
      </div>
    </div>
  </div>
)}

<script>
  function initSlideNavigation() {
    const containers = document.querySelectorAll('.marp-slides-container');

    containers.forEach(container => {
      const slides = container.querySelectorAll('.marp-slide');
      const prevBtn = container.querySelector('.marp-prev') as HTMLButtonElement;
      const nextBtn = container.querySelector('.marp-next') as HTMLButtonElement;
      const fullscreenBtn = container.querySelector('.marp-fullscreen') as HTMLButtonElement;
      const currentSpan = container.querySelector('.marp-current');

      if (!slides.length || !prevBtn || !nextBtn || !currentSpan) return;

      let currentIndex = 0;
      const totalSlides = slides.length;

      function updateSlide(newIndex: number) {
        if (newIndex < 0 || newIndex >= totalSlides) return;

        slides[currentIndex].classList.remove('active');
        slides[newIndex].classList.add('active');
        currentIndex = newIndex;

        if (currentSpan) {
          currentSpan.textContent = String(currentIndex + 1);
        }

        prevBtn.disabled = currentIndex === 0;
        nextBtn.disabled = currentIndex === totalSlides - 1;
      }

      prevBtn.addEventListener('click', () => updateSlide(currentIndex - 1));
      nextBtn.addEventListener('click', () => updateSlide(currentIndex + 1));

      // Fullscreen functionality
      if (fullscreenBtn) {
        fullscreenBtn.addEventListener('click', async () => {
          try {
            if (!document.fullscreenElement) {
              await container.requestFullscreen();
            } else {
              await document.exitFullscreen();
            }
          } catch (err) {
            console.error('Fullscreen error:', err);
          }
        });

        // Update button state on fullscreen change
        document.addEventListener('fullscreenchange', () => {
          container.classList.toggle('is-fullscreen', document.fullscreenElement === container);
        });
      }

      // Keyboard navigation
      container.addEventListener('keydown', (e: Event) => {
        const keyEvent = e as KeyboardEvent;
        if (keyEvent.key === 'ArrowLeft') {
          updateSlide(currentIndex - 1);
        } else if (keyEvent.key === 'ArrowRight') {
          updateSlide(currentIndex + 1);
        } else if (keyEvent.key === 'Escape' && document.fullscreenElement) {
          document.exitFullscreen();
        }
      });
    });
  }

  // Initialize on page load
  initSlideNavigation();

  // Re-initialize on Astro page transitions
  document.addEventListener('astro:page-load', initSlideNavigation);
</script>
